===== ./dto/response/JobResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.response;

import lombok.Data;

@Data
public class JobResponse {
    private Long id;
    private String jobDescription;
}
===== ./dto/response/UserResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.response;

import lombok.Data;

@Data
public class UserResponse {
    private Long id;
    private String firstName;
    private String lastName;
    private String username;
    private String role;
}
===== ./dto/response/ProfileResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.response;

import lombok.Data;

@Data
public class ProfileResponse {
    private Long id;
    private String profileName;
    private String profileDescription;
    private String username;
}
===== ./dto/request/CreateProfileRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.request;

import lombok.Data;
import jakarta.validation.constraints.NotBlank;

@Data
public class CreateProfileRequest {
    @NotBlank
    private String profileName;

    @NotBlank
    private String profileDescription;
}===== ./dto/request/CreateJobRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.request;

import lombok.Data;

@Data
public class CreateJobRequest {
    private String jobDescription;
}
===== ./dto/request/UpdateResumeRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.request;

import lombok.Data;

@Data
public class UpdateResumeRequest {
    private String username;
    private String profileName;
    private String jobDescription;
}
===== ./repository/ProfileRepository.java =====
package edu.miu.cs.cs489.resumerefinerai.repository;

import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface ProfileRepository extends JpaRepository<Profile, Long> {
    List<Profile> findByUser(User user);
    Optional<Profile> findByUserAndProfileName(User user, String profileName);
    boolean existsByUserAndProfileName(User user, String profileName);

}
===== ./repository/JobRepository.java =====
package edu.miu.cs.cs489.resumerefinerai.repository;

import edu.miu.cs.cs489.resumerefinerai.model.Job;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface JobRepository extends JpaRepository<Job, Long> {
    // Optional: Add custom query methods if needed later
}===== ./util/DockerLatexCompiler.java =====
package edu.miu.cs.cs489.resumerefinerai.util;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class DockerLatexCompiler {

    public static boolean compileWithDocker(Path mainTexFile) {
        String texFileName = mainTexFile.getFileName().toString();
        Path parentDir = mainTexFile.getParent();

        try {
            Process process = new ProcessBuilder(
                    "docker", "run", "--rm",
                    "-v", parentDir.toAbsolutePath() + ":/data",
                    "custom-latex",
                    "pdflatex", "-output-directory=/data", texFileName  // <-- no quotes
            ).directory(parentDir.toFile())
                    .redirectErrorStream(true)
                    .start();

            String output = new String(process.getInputStream().readAllBytes());
            int exitCode = process.waitFor();

            if (exitCode != 0) {
                System.err.println("❌ LaTeX ERROR OUTPUT:");
                System.err.println(output);

                // Read the log file if available
                Path logFile = parentDir.resolve(texFileName.replace(".tex", ".log"));
                if (Files.exists(logFile)) {
                    System.err.println("\n📄 LaTeX LOG CONTENT:");
                    System.err.println(Files.readString(logFile));
                }

                return false;
            }

            return true;
        } catch (Exception e) {
            throw new RuntimeException("Docker LaTeX compilation failed", e);
        }
    }

}
===== ./config/JwtService.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.util.Collection;
import java.util.Date;
import java.util.stream.Collectors;

@Service
public class JwtService {

    @Value("${jwt.secretKey}")
    private String SECRET;

    public String generateToken(UserDetails userDetails) {
        return Jwts.builder()
                .claim("authorities", populateAuthorities(userDetails.getAuthorities()))
                .subject(userDetails.getUsername())
                .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
                .issuer("compro.miu.edu")
                .issuedAt(new Date())
                .signWith(signInKey())
                .compact();
    }

    private String populateAuthorities(Collection<? extends GrantedAuthority> authorities) {
        return authorities.stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));
    }

    private SecretKey signInKey() {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(SECRET));
    }

    public Claims getClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(signInKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
===== ./config/OpenApiConfig.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.OpenAPI;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Resume Refiner AI API")
                        .version("1.0")
                        .description("API documentation for user registration, authentication, and role-based access"));
    }
}
===== ./config/ApplicationConfiguration.java =====
package edu.miu.cs.cs489.resumerefinerai.config;


import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfiguration {

    private final UserRepository userRepository;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByUsername(username).orElseThrow(() -> new UsernameNotFoundException(username));
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setUserDetailsService(userDetailsService());
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
        return daoAuthenticationProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
===== ./config/JwtFilter.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String authorizationHeader = request.getHeader("Authorization");
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            String token = authorizationHeader.substring(7);
            //Extract username from token
            String username = jwtService.getClaimsFromToken(token).getSubject();
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                SecurityContextHolder.getContext().setAuthentication(
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        )
                );
            }
        }
        filterChain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        return request.getServletPath().contains("/api/v1/auth");
    }
}
===== ./config/SecurityConfiguration.java =====
package edu.miu.cs.cs489.resumerefinerai.config;


import edu.miu.cs.cs489.resumerefinerai.auth.user.Permission;
import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.CsrfConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtFilter jwtFilter;
    private final AuthenticationProvider authenticationProvider;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
//        http.authorizeHttpRequests().requestMatchers("/public/**").permitAll().anyRequest()
//                .hasRole("USER").and()
//                // Possibly more configuration ...
//                .formLogin() // enable form based log in
//                // set permitAll for all URLs associated with Form Login
//                .permitAll();
//        return http.build();
        http.csrf(CsrfConfigurer::disable)
                .authorizeHttpRequests(
                        authorizeRequests ->
                                authorizeRequests
                                        .requestMatchers("/api/v1/auth/*").permitAll()

                                        .requestMatchers(
                                                "/api/v1/auth/**",           // already there
                                                "/v3/api-docs/**",           // for OpenAPI spec
                                                "/swagger-ui/**",            // for Swagger assets
                                                "/swagger-ui.html"           // Swagger UI page
                                        ).permitAll()



                                        .requestMatchers("/api/v1/management/**").hasAnyRole(Role.ADMIN.name(), Role.MEMBER.name())
                                        .requestMatchers("/api/v1/admin").hasRole(Role.ADMIN.name())
                                        .requestMatchers("/api/v1/management/admin-write").hasAuthority(Permission.ADMIN_WRITE.getPermission())
                                        .requestMatchers("/api/v1/management/for-all").hasAnyAuthority(
                                                Permission.MEMBER_READ.getPermission(),
                                                Permission.MEMBER_WRITE.getPermission(),
                                                Permission.ADMIN_WRITE.getPermission(),
                                                Permission.ADMIN_READ.getPermission()
                                        )
                                        .anyRequest().permitAll()
//                                        .anyRequest().authenticated()
//                                        .requestMatchers("/api/v1/auth/authenticate").permitAll()
                )
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .authenticationProvider(authenticationProvider)
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        ;
        return http.build();
    }
}
===== ./auth/dto/response/AuthenticationResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.dto.response;

public record AuthenticationResponse(
        String token
) {
}
===== ./auth/dto/request/RegisterRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.dto.request;


import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;

public record RegisterRequest(
        String firstName,
        String lastName,
        String username,
        String password,
        Role role
) {
}
===== ./auth/dto/request/AuthenticationRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.dto.request;

public record AuthenticationRequest(
        String username,
        String password
) {
}
===== ./auth/repository/UserRepository.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.repository;

import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
===== ./auth/user/User.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.user;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String firstName;
    private String lastName;

    @Column(unique = true, nullable = false)
    private String username;
    private String password;

    @Enumerated(EnumType.STRING)
    private Role role;

    public User(String firstName, String lastName, String username, String password, Role role) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.username = username;
        this.password = password;
        this.role = role;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return role.getAuthorities();
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

}
===== ./auth/user/Permission.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.user;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Permission {
    ADMIN_READ("admin:read"),
    ADMIN_WRITE("admin:write"),
    MEMBER_READ("member:read"),
    MEMBER_WRITE("member:write");

    @Getter
    private final String permission;
}
===== ./auth/user/Role.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.user;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public enum Role {
    ADMIN(Set.of(Permission.ADMIN_WRITE, Permission.ADMIN_READ)),
    MEMBER(Set.of(Permission.MEMBER_WRITE, Permission.MEMBER_READ));

    @Getter
    private final Set<Permission> permissions;

    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<SimpleGrantedAuthority> authorities = getPermissions().stream()
                .map(permission -> new SimpleGrantedAuthority(permission.getPermission()))
                .collect(Collectors.toList());
        authorities.add(new SimpleGrantedAuthority("ROLE_"+name()));
        return authorities;
    }
}
===== ./auth/controller/AuthenticationController.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.controller;

import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.AuthenticationRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.RegisterRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.response.AuthenticationResponse;
import edu.miu.cs.cs489.resumerefinerai.auth.service.AuthenticationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthenticationController {

    private final AuthenticationService authenticationService;
    /***
     * for /register
     */
    @PostMapping("/register")
    public ResponseEntity<AuthenticationResponse> register(@RequestBody RegisterRequest registerRequest) {
        AuthenticationResponse authenticationResponse = authenticationService.register(registerRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(authenticationResponse);
    }

    /***
     * for /authenticate
     */
    //AuthenticationResponse authenticate(authenticationRequest)
    @PostMapping("/authenticate")
    private ResponseEntity<AuthenticationResponse> authenticate(@RequestBody AuthenticationRequest authenticationRequest) {
        AuthenticationResponse authenticationResponse = authenticationService.authenticate(authenticationRequest);
        return ResponseEntity.status(HttpStatus.OK).body(authenticationResponse);
    }
}
===== ./auth/service/AuthenticationService.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.service;

import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.RegisterRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.AuthenticationRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.response.AuthenticationResponse;
import edu.miu.cs.cs489.resumerefinerai.config.JwtService;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final JwtService jwtService;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;

    public AuthenticationResponse authenticate(AuthenticationRequest authenticationRequest) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        authenticationRequest.username(),
                        authenticationRequest.password()
                )
        );
        //generate token for the user
        var user = (User) authentication.getPrincipal();
        String token = jwtService.generateToken(user);
        return new AuthenticationResponse(token);
    }

    public AuthenticationResponse register(RegisterRequest registerRequest) {
        User user = new User(
                registerRequest.firstName(),
                registerRequest.lastName(),
                registerRequest.username(),
                passwordEncoder.encode(registerRequest.password()),
                registerRequest.role()
        );
        User registeredUser = userRepository.save(user);
        //Generate token for this user
        String token = jwtService.generateToken(registeredUser);
        return new AuthenticationResponse(token);
    }
}
===== ./ResumeRefinerAiApplication.java =====
package edu.miu.cs.cs489.resumerefinerai;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ResumeRefinerAiApplication {

    public static void main(String[] args) {
        SpringApplication.run(ResumeRefinerAiApplication.class, args);
    }

}
===== ./mapper/JobMapper.java =====
package edu.miu.cs.cs489.resumerefinerai.mapper;

import edu.miu.cs.cs489.resumerefinerai.dto.response.JobResponse;
import edu.miu.cs.cs489.resumerefinerai.model.Job;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface JobMapper {
    JobResponse toDto(Job job);
}
===== ./mapper/UserMapper.java =====
package edu.miu.cs.cs489.resumerefinerai.mapper;

import edu.miu.cs.cs489.resumerefinerai.dto.response.UserResponse;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface UserMapper {
    UserResponse toDto(User user);
}
===== ./mapper/ProfileMapper.java =====
package edu.miu.cs.cs489.resumerefinerai.mapper;

import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.dto.response.ProfileResponse;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface ProfileMapper {
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "user", source = "user")
    Profile toEntity(CreateProfileRequest dto, User user);

    @Mapping(target = "username", source = "user.username")
    ProfileResponse toDto(Profile profile);
}
===== ./controller/ProfileController.java =====
package edu.miu.cs.cs489.resumerefinerai.controller;

import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.dto.response.ProfileResponse;
import edu.miu.cs.cs489.resumerefinerai.mapper.ProfileMapper;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.service.ProfileService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/v1/profiles")
@RequiredArgsConstructor
public class ProfileController {

    private final ProfileService profileService;
    private final ProfileMapper profileMapper;

    @PostMapping("/{username}")
    public ResponseEntity<ProfileResponse> createProfile(
            @PathVariable String username,
            @Valid @RequestBody CreateProfileRequest request
    ) {
        Profile profile = profileService.createProfile(username, request);
        return ResponseEntity.ok(profileMapper.toDto(profile));
    }

    @GetMapping("/{username}")
    public ResponseEntity<List<Profile>> getUserProfiles(@PathVariable String username) {
        return ResponseEntity.ok(profileService.getUserProfiles(username));
    }

    @GetMapping("/{username}/{profileName}")
    public ResponseEntity<Profile> getSingleProfile(
            @PathVariable String username,
            @PathVariable String profileName) {
        return ResponseEntity.ok(profileService.getProfile(username, profileName));
    }


    @PostMapping("/{username}/{profileName}/upload")
    public ResponseEntity<String> uploadLatexZip(
            @PathVariable String username,
            @PathVariable String profileName,
            @RequestParam("file") MultipartFile file
    ) {
        try {
            profileService.extractLatexZip(username, profileName, file);
            return ResponseEntity.ok("Upload and extraction successful.");
        } catch (RuntimeException | IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Upload failed: " + e.getMessage());
        }
    }


}
===== ./controller/ResumeController.java =====
package edu.miu.cs.cs489.resumerefinerai.controller;

import edu.miu.cs.cs489.resumerefinerai.dto.request.UpdateResumeRequest;
import edu.miu.cs.cs489.resumerefinerai.service.ResumeService;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;

@RestController
@RequestMapping("/api/v1/resume")
public class ResumeController {

    private final ResumeService resumeService;

    public ResumeController(ResumeService resumeService) {
        this.resumeService = resumeService;
    }

    @PostMapping("/update")
    public ResponseEntity<String> updateResume(@RequestBody UpdateResumeRequest request) {
        try {
            resumeService.updateResume(request);
            return ResponseEntity.ok("Resume updated and compiled successfully.");
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
        }
    }

    @GetMapping("/download/{username}/{profileName}")
    public ResponseEntity<FileSystemResource> downloadResume(
            @PathVariable String username,
            @PathVariable String profileName
    ) {
        Path pdfPath = resumeService.getPdfPathForUser(username, profileName);
        File pdf = pdfPath.toFile();

        if (!pdf.exists()) return ResponseEntity.notFound().build();

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + profileName + ".pdf")
                .contentType(MediaType.APPLICATION_PDF)
                .body(new FileSystemResource(pdf));
    }

}
===== ./model/Profile.java =====
package edu.miu.cs.cs489.resumerefinerai.model;

import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(
        name = "profiles",
        uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "profile_name"})
)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Profile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "profile_name")
    private String profileName;

    private String profileDescription;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
===== ./model/Job.java =====
package edu.miu.cs.cs489.resumerefinerai.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "jobs")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Job {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String jobDescription;

}
===== ./service/ProfileService.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.exception.DuplicateProfileException;
import edu.miu.cs.cs489.resumerefinerai.mapper.ProfileMapper;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.repository.ProfileRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.*;
import java.util.Comparator;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ProfileService {

    private final ProfileRepository profileRepository;
    private final UserRepository userRepository;
    private final ProfileMapper profileMapper;


    public Profile createProfile(String username, CreateProfileRequest request) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));

        boolean exists = profileRepository.existsByUserAndProfileName(user, request.getProfileName());
        if (exists) {
            throw new DuplicateProfileException("Profile name already exists for this user.");
        }


        Profile profile = profileMapper.toEntity(request, user);
        Profile savedProfile = profileRepository.save(profile);
        createLatexFolderStructure(user, savedProfile.getProfileName());
        return savedProfile;
    }


    public List<Profile> getUserProfiles(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return profileRepository.findByUser(user);
    }

    public Profile getProfile(String username, String profileName) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return profileRepository.findByUserAndProfileName(user, profileName)
                .orElseThrow(() -> new RuntimeException("Profile not found"));
    }

    private void createLatexFolderStructure(User user, String profileName) {
        String userId = String.valueOf(user.getId());
        Path baseDir = Paths.get("src/main/resources/latex", userId, profileName);
        Path sectionsDir = baseDir.resolve("sections");

        try {
            // 💣 Delete old folder if it exists
            if (Files.exists(baseDir)) {
                deleteDirectoryRecursively(baseDir);
            }

            Files.createDirectories(sectionsDir);

            // Create empty .tex files
            List<String> sectionFiles = List.of(
                    "summary.tex", "skills.tex", "experience.tex",
                    "projects.tex", "educations.tex", "publications.tex"
            );
            for (String filename : sectionFiles) {
                Files.createFile(sectionsDir.resolve(filename));
            }

            Files.createFile(baseDir.resolve("header.tex"));
            Files.createFile(baseDir.resolve(profileName + ".tex"));

        } catch (IOException e) {
            throw new RuntimeException("Could not create LaTeX folder structure", e);
        }
    }

    private void deleteDirectoryRecursively(Path path) throws IOException {
        if (Files.notExists(path)) return;

        Files.walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(p -> {
                    try {
                        Files.deleteIfExists(p);
                    } catch (IOException e) {
                        throw new RuntimeException("Failed to delete " + p, e);
                    }
                });
    }

    public void extractLatexZip(String username, String profileName, MultipartFile zipFile) throws IOException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Profile profile = profileRepository.findByUserAndProfileName(user, profileName)
                .orElseThrow(() -> new RuntimeException("Profile not found"));

        Path extractTo = Paths.get("src/main/resources/template", String.valueOf(user.getId()), profileName);
        Files.createDirectories(extractTo);

        Path tempZip = Files.createTempFile("upload-", ".zip");
        zipFile.transferTo(tempZip.toFile());

        System.out.println("TEMP ZIP PATH: " + tempZip);
        System.out.println("Exists? " + Files.exists(tempZip));
        System.out.println("Size: " + Files.size(tempZip));

        try (FileSystem zipFs = FileSystems.newFileSystem(tempZip, (ClassLoader) null)) {
            for (Path root : zipFs.getRootDirectories()) {
                Files.walk(root)
                        .filter(Files::isRegularFile)
                        .forEach(zipEntry -> {
                            try {
                                Path relativePath = root.relativize(zipEntry);
                                Path target = extractTo.resolve(relativePath.toString());
                                Files.createDirectories(target.getParent());
                                Files.copy(zipEntry, target, StandardCopyOption.REPLACE_EXISTING);
                            } catch (IOException e) {
                                throw new RuntimeException("Failed to extract: " + zipEntry, e);
                            }
                        });
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to open zip file: " + tempZip, e);
        } finally {
            Files.deleteIfExists(tempZip);
        }
    }

}===== ./service/OpenAIService.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import com.openai.client.OpenAIClient;
import com.openai.client.okhttp.OpenAIOkHttpClient;
import com.openai.models.ChatModel;
import com.openai.models.chat.completions.ChatCompletion;
import com.openai.models.chat.completions.ChatCompletionCreateParams;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class OpenAIService {

    private final OpenAIClient client;

    public OpenAIService(@Value("${openai.api.key}") String apiKey) {
        this.client = OpenAIOkHttpClient.builder()
                .apiKey(apiKey)
                .build();
    }

    public String getUpdatedSection(String sectionName, String sectionContent, String jobDescription) {
        String prompt = "You are a resume writing expert. Rewrite ONLY the LaTeX content of the resume section '" + sectionName +
                "' based on the job description below. Return ONLY LaTeX code between \\begin{} and \\end{}, no explanation, no Markdown, no notes.\n\n" +
                "Job Description:\n" + jobDescription + "\n\nCurrent LaTeX Section:\n" + sectionContent;


        ChatCompletionCreateParams params = ChatCompletionCreateParams.builder()
                .addUserMessage(prompt)
                .model(ChatModel.GPT_4_1)
                .build();

        ChatCompletion completion = client.chat().completions().create(params);
        return completion.choices().get(0).message().content().orElse("%% Error: no content received");
    }
}
===== ./service/ResumeService.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.dto.request.UpdateResumeRequest;
import edu.miu.cs.cs489.resumerefinerai.repository.ProfileRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import edu.miu.cs.cs489.resumerefinerai.util.DockerLatexCompiler;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.*;
import java.util.Comparator;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ResumeService {

    private final OpenAIService openAIService;
    private final ProfileRepository profileRepository;
    private final UserRepository userRepository;

    public void updateResume(UpdateResumeRequest request) throws IOException {
        // 1. Get user and profile
        User user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found"));
        Profile profile = profileRepository.findByUserAndProfileName(user, request.getProfileName())
                .orElseThrow(() -> new RuntimeException("Profile not found"));

        String userId = String.valueOf(user.getId());
        String profileName = profile.getProfileName();
        String resumeFileName = user.getFirstName() + " " + user.getLastName() + " Resume.tex";

        // 2. Build paths
        Path templateRoot = Paths.get("src/main/resources/template", userId, profileName);
        Path latexRoot = Paths.get("src/main/resources/latex", userId, profileName);
        Path mainTexFile = latexRoot.resolve(resumeFileName);

        // 3. Clean and copy template to latex
        if (Files.exists(latexRoot)) {
            deleteDirectoryRecursively(latexRoot);
        }
        Files.createDirectories(latexRoot);
        copyDirectoryRecursively(templateRoot, latexRoot);

        // 4. Update selective sections using OpenAI
        List<String> updatableSections = List.of("summary.tex", "skills.tex", "experience.tex");
        Path sectionsDir = latexRoot.resolve("sections");

        for (String section : updatableSections) {
            Path targetFile = sectionsDir.resolve(section);
            if (!Files.exists(targetFile)) {
                throw new RuntimeException("Missing section file: " + targetFile.toAbsolutePath());
            }

            String original = Files.readString(targetFile);
            String updated = openAIService.getUpdatedSection(section, original, request.getJobDescription());
            Files.writeString(targetFile, updated);

            System.out.println("Section updated: " + section);
        }

        // 5. Compile with Docker
        boolean compiled = DockerLatexCompiler.compileWithDocker(mainTexFile);
        if (!compiled) {
            throw new RuntimeException("LaTeX compilation failed.");
        }

        System.out.println("Resume compiled: " + mainTexFile);
    }

    private void deleteDirectoryRecursively(Path path) throws IOException {
        Files.walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(p -> {
                    try {
                        Files.deleteIfExists(p);
                    } catch (IOException e) {
                        throw new RuntimeException("Failed to delete " + p, e);
                    }
                });
    }

    private void copyDirectoryRecursively(Path source, Path target) throws IOException {
        Files.walk(source).forEach(src -> {
            try {
                Path dest = target.resolve(source.relativize(src));
                if (Files.isDirectory(src)) {
                    Files.createDirectories(dest);
                } else {
                    Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);
                }
            } catch (IOException e) {
                throw new RuntimeException("Failed to copy " + src + " to " + target, e);
            }
        });
    }


    public Path getCompiledPdfPath(String userId, String profileName) {
        return Paths.get("src/main/resources/latex", userId, profileName, profileName + ".pdf");
    }

    public Path getPdfPathForUser(String username, String profileName) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
        String fileName = user.getFirstName() + " " + user.getLastName() + " Resume.pdf";
        return Paths.get("src/main/resources/latex", String.valueOf(user.getId()), profileName, fileName);
    }
}
===== ./exception/DuplicateProfileException.java =====
package edu.miu.cs.cs489.resumerefinerai.exception;

public class DuplicateProfileException extends RuntimeException {
    public DuplicateProfileException(String message) {
        super(message);
    }
}
===== ./secured/AdminController.java =====
package edu.miu.cs.cs489.resumerefinerai.secured;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/admin")
public class AdminController {

    @GetMapping
    public String getAdmin() {
        return "Admin: secured end point";
    }
}
===== ./secured/MemberController.java =====
package edu.miu.cs.cs489.resumerefinerai.secured;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/management")
public class MemberController {

    @GetMapping
    public String getMember() {
        return "Member: secured end point";
    }

    @GetMapping("/admin-write")
    @PreAuthorize("hasAuthority('admin:write')")
    public String memberOnlyForAdminWrite() {
        return "Member: secured end point only for admin write";
    }

    @GetMapping("for-all")
    @PreAuthorize("hasAnyAuthority('admin-write', 'admin-read', 'member-write', 'member-read')")
    public String memberOnlyForAll() {
        return "Member: secured end point only for all";
    }

}
