===== ./test/java/edu/miu/cs/cs489/resumerefinerai/repository/ProfileRepositoryTest.java =====
package edu.miu.cs.cs489.resumerefinerai.repository;

import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.config.TestConfig;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.context.annotation.Import;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;

import java.util.List;
import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
@Import(TestConfig.class)
public class ProfileRepositoryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private ProfileRepository profileRepository;

    @Test
    void findByUser_WithPagination_ReturnsPage() {
        // 1. Create and persist User
        User user = new User("Test", "User", "testuser", "password", Role.MEMBER);
        entityManager.persist(user);

        // 2. Create Profile WITH USER REFERENCE
        Profile profile = new Profile();
        profile.setProfileName("Data Engineer");
        profile.setUser(user); // Explicitly set user
        entityManager.persist(profile);

        // 3. Force flush and clear cache
        entityManager.flush();
        entityManager.clear();

        // 4. Query
        Page<Profile> result = profileRepository.findByUser(
                user,
                PageRequest.of(0, 10)
        );

        assertEquals(1, result.getTotalElements());
    }
}===== ./test/java/edu/miu/cs/cs489/resumerefinerai/config/TestConfig.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class TestConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
===== ./test/java/edu/miu/cs/cs489/resumerefinerai/auth/service/AuthenticationServiceTest.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.service;

import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.AuthenticationRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.RegisterRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.response.AuthenticationResponse;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.config.JwtService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.password.PasswordEncoder;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class AuthenticationServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock(strictness = Mock.Strictness.LENIENT)
    private JwtService jwtService;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private AuthenticationManager authenticationManager;

    @InjectMocks
    private AuthenticationService authenticationService;



    @Test
    void register_NewUser_ReturnsToken() {
        // Mock User object properly
        User mockUser = new User("Arif", "Rahman", "arif", "encodedPassword", Role.MEMBER);
        when(userRepository.save(any(User.class))).thenReturn(mockUser);
        when(jwtService.generateToken(mockUser)).thenReturn("jwt-token");


        // Arrange
        RegisterRequest request = new RegisterRequest("Arif", "Rahman", "arif", "password", Role.MEMBER);
        when(userRepository.findByUsername("arif")).thenReturn(Optional.empty());
        when(passwordEncoder.encode("password")).thenReturn("encodedPassword");
        when(jwtService.generateToken(any(User.class))).thenReturn("jwt-token");

        // Act
        AuthenticationResponse response = authenticationService.register(request);

        // Assert
        assertEquals("jwt-token", response.token());
    }
}===== ./test/java/edu/miu/cs/cs489/resumerefinerai/controller/ProfileControllerIntegrationTest.java =====
package edu.miu.cs.cs489.resumerefinerai.controller;

import edu.miu.cs.cs489.resumerefinerai.ResumeRefinerAiApplication;
import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.repository.ProfileRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest(classes = ResumeRefinerAiApplication.class)
@AutoConfigureMockMvc
class ProfileControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ProfileRepository profileRepository;

    private User testUser;

    @BeforeEach
    void setup() {
        testUser = userRepository.save(new User("Test", "User", "testuser", "password", Role.MEMBER));
    }

    @AfterEach
    void tearDown() {
        profileRepository.deleteAll();
        userRepository.deleteAll();
    }

    @Test
    void createProfile_ValidRequest_ReturnsCreated() throws Exception {
        // Arrange
        String requestBody = """
            {
                "profileName": "Data Engineer",
                "profileDescription": "Builds data pipelines"
            }
            """;

        // Act & Assert
        mockMvc.perform(post("/api/v1/profiles/testuser")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.profileName").value("Data Engineer"));
    }
}===== ./test/java/edu/miu/cs/cs489/resumerefinerai/controller/SecurityIntegrationTest.java =====
package edu.miu.cs.cs489.resumerefinerai.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import edu.miu.cs.cs489.resumerefinerai.ResumeRefinerAiApplication;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.response.AuthenticationResponse;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.web.servlet.MockMvc;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest(classes = ResumeRefinerAiApplication.class)
@AutoConfigureMockMvc
class SecurityIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    private User testUser;

    @BeforeEach
    void setup() {
        // Create and save test user with encoded password
        testUser = new User("Test", "User", "testuser",
                passwordEncoder.encode("password"), Role.MEMBER);
        userRepository.save(testUser);
    }

    @Test
    void accessSecuredEndpoint_WithValidToken_ReturnsOk() throws Exception {
        // Get valid JWT token
        String token = authenticateAndGetToken("testuser", "password");

        mockMvc.perform(get("/api/v1/profiles/testuser")
                        .header("Authorization", "Bearer " + token))
                .andExpect(status().isOk());
    }

    private String authenticateAndGetToken(String username, String password) throws Exception {
        String requestBody = """
            {
                "username": "%s",
                "password": "%s"
            }
            """.formatted(username, password);

        String response = mockMvc.perform(post("/api/v1/auth/authenticate")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();

        return new ObjectMapper().readTree(response).get("token").asText(); // Proper JSON parsing
    }
}===== ./test/java/edu/miu/cs/cs489/resumerefinerai/service/ProfileServiceTest.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.dto.response.ProfileResponse;
import edu.miu.cs.cs489.resumerefinerai.mapper.ProfileMapper;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.repository.ProfileRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class ProfileServiceTest {

    @Mock
    private ProfileRepository profileRepository;

    @Mock
    private UserRepository userRepository;

    @Mock
    private ProfileMapper profileMapper;

    @InjectMocks
    private ProfileService profileService;

    private CreateProfileRequest request;
    private ProfileResponse mockResponse;

    private CreateProfileRequest validRequest;

    @BeforeEach
    void setup() {
        // Initialize valid request
        validRequest = new CreateProfileRequest("Dev", "Description");

        // Configure mapper
        User mockUser = new User("Test", "User", "testuser", "pass", Role.MEMBER);
        when(profileMapper.toEntity(validRequest, mockUser))
                .thenReturn(new Profile(1L, "Dev", "Desc", mockUser));
    }

    @Test
    void createProfile_Success() {
        // Use initialized request
        ProfileResponse response = profileService.createProfile("testuser", validRequest);
        assertNotNull(response);
    }

//    @Test
//    void createProfile_Success() {
//        // Arrange
//        User mockUser = new User("Test", "User", "testuser", "password", Role.MEMBER);
//        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(mockUser));
//        when(profileRepository.existsByUserAndProfileName(any(), any())).thenReturn(false);
//        when(profileRepository.save(any())).thenReturn(new Profile());
//
//        // Act
//        ProfileResponse response = profileService.createProfile("testuser", request);
//
//        // Assert
//        assertNotNull(response);
//        assertEquals("Data Engineer", response.getProfileName());
//        verify(profileMapper, times(1)).toDto(any(Profile.class));
//    }
}===== ./test/java/edu/miu/cs/cs489/resumerefinerai/ResumeRefinerAiApplicationTests.java =====
package edu.miu.cs.cs489.resumerefinerai;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ResumeRefinerAiApplicationTests {

    @Test
    void contextLoads() {
    }

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/dto/response/JobResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.response;

import lombok.Data;

@Data
public class JobResponse {
    private Long id;
    private String jobDescription;
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/dto/response/UserResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.response;

import lombok.Data;

@Data
public class UserResponse {
    private Long id;
    private String firstName;
    private String lastName;
    private String username;
    private String role;
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/dto/response/ProfileResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ProfileResponse {
    private Long id;
    private String profileName;
    private String profileDescription;
    private String username;
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/dto/request/CreateProfileRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.request;

import lombok.AllArgsConstructor;
import lombok.Data;
import jakarta.validation.constraints.NotBlank;

@Data
@AllArgsConstructor
public class CreateProfileRequest {
    @NotBlank
    private String profileName;

    @NotBlank
    private String profileDescription;
}===== ./main/java/edu/miu/cs/cs489/resumerefinerai/dto/request/CreateJobRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.request;

import lombok.Data;

@Data
public class CreateJobRequest {
    private String jobDescription;
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/dto/request/UpdateResumeRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.dto.request;

import lombok.Data;

@Data
public class UpdateResumeRequest {
    private String username;
    private String profileName;
    private String jobDescription;
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/repository/ProfileRepository.java =====
package edu.miu.cs.cs489.resumerefinerai.repository;

import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;


import java.util.List;
import java.util.Optional;

public interface ProfileRepository extends JpaRepository<Profile, Long> {
    Page<Profile> findByUser(User user, Pageable pageable);
    Optional<Profile> findByUserAndProfileName(User user, String profileName);
    boolean existsByUserAndProfileName(User user, String profileName);

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/repository/JobRepository.java =====
package edu.miu.cs.cs489.resumerefinerai.repository;

import edu.miu.cs.cs489.resumerefinerai.model.Job;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface JobRepository extends JpaRepository<Job, Long> {
    // Optional: Add custom query methods if needed later
}===== ./main/java/edu/miu/cs/cs489/resumerefinerai/util/DockerLatexCompiler.java =====
package edu.miu.cs.cs489.resumerefinerai.util;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

public class DockerLatexCompiler {

    public static boolean compileWithDocker(Path mainTexFile) {
        String texFileName = mainTexFile.getFileName().toString();
        Path parentDir = mainTexFile.getParent();

        try {
            Process process = new ProcessBuilder(
                    "docker", "run", "--rm",
                    "-v", parentDir.toAbsolutePath() + ":/data",
                    "custom-latex",
                    "pdflatex", "-output-directory=/data", texFileName  // <-- no quotes
            ).directory(parentDir.toFile())
                    .redirectErrorStream(true)
                    .start();

            String output = new String(process.getInputStream().readAllBytes());
            int exitCode = process.waitFor();

            if (exitCode != 0) {
                System.err.println("âŒ LaTeX ERROR OUTPUT:");
                System.err.println(output);

                // Read the log file if available
                Path logFile = parentDir.resolve(texFileName.replace(".tex", ".log"));
                if (Files.exists(logFile)) {
                    System.err.println("\nðŸ“„ LaTeX LOG CONTENT:");
                    System.err.println(Files.readString(logFile));
                }

                return false;
            }

            return true;
        } catch (Exception e) {
            throw new RuntimeException("Docker LaTeX compilation failed", e);
        }
    }

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/config/JwtService.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.util.Collection;
import java.util.Date;
import java.util.stream.Collectors;

@Service
public class JwtService {

    @Value("${jwt.secretKey}")
    private String SECRET;

    public String generateToken(UserDetails userDetails) {
        return Jwts.builder()
                .claim("authorities", populateAuthorities(userDetails.getAuthorities()))
                .subject(userDetails.getUsername())
                .expiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 24))
                .issuer("compro.miu.edu")
                .issuedAt(new Date())
                .signWith(signInKey())
                .compact();
    }

    private String populateAuthorities(Collection<? extends GrantedAuthority> authorities) {
        return authorities.stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));
    }

    private SecretKey signInKey() {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(SECRET));
    }

    public Claims getClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(signInKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/config/OpenApiConfig.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.OpenAPI;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Resume Refiner AI API")
                        .version("1.0")
                        .description("API documentation for user registration, authentication, and role-based access"));
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/config/ApplicationConfiguration.java =====
package edu.miu.cs.cs489.resumerefinerai.config;


import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfiguration {

    private final UserRepository userRepository;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByUsername(username).orElseThrow(() -> new UsernameNotFoundException(username));
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setUserDetailsService(userDetailsService());
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
        return daoAuthenticationProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/config/JwtFilter.java =====
package edu.miu.cs.cs489.resumerefinerai.config;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String authorizationHeader = request.getHeader("Authorization");

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            String token = authorizationHeader.substring(7);
            try {
                // Extract username from token
                String username = jwtService.getClaimsFromToken(token).getSubject();
                if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                    SecurityContextHolder.getContext().setAuthentication(
                            new UsernamePasswordAuthenticationToken(
                                    userDetails,
                                    null,
                                    userDetails.getAuthorities()
                            )
                    );
                }
            } catch (io.jsonwebtoken.ExpiredJwtException e) {
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "JWT expired");
                return;
            } catch (io.jsonwebtoken.JwtException | IllegalArgumentException e) {
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Invalid JWT");
                return;
            }
        }
        filterChain.doFilter(request, response);
    }


    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        return request.getServletPath().contains("/api/v1/auth");
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/config/SecurityConfiguration.java =====
package edu.miu.cs.cs489.resumerefinerai.config;


import edu.miu.cs.cs489.resumerefinerai.auth.user.Permission;
import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.CsrfConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtFilter jwtFilter;
    private final AuthenticationProvider authenticationProvider;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
//        http.authorizeHttpRequests().requestMatchers("/public/**").permitAll().anyRequest()
//                .hasRole("USER").and()
//                // Possibly more configuration ...
//                .formLogin() // enable form based log in
//                // set permitAll for all URLs associated with Form Login
//                .permitAll();
//        return http.build();
        http.csrf(CsrfConfigurer::disable)
                .authorizeHttpRequests(
                        authorizeRequests ->
                                authorizeRequests
                                        .requestMatchers("/api/v1/auth/*").permitAll()

                                        .requestMatchers(
                                                "/api/v1/auth/**",           // already there
                                                "/v3/api-docs/**",           // for OpenAPI spec
                                                "/swagger-ui/**",            // for Swagger assets
                                                "/swagger-ui.html"           // Swagger UI page
                                        ).permitAll()



                                        .requestMatchers("/api/v1/management/**").hasAnyRole(Role.ADMIN.name(), Role.MEMBER.name())
                                        .requestMatchers("/api/v1/admin").hasRole(Role.ADMIN.name())
                                        .requestMatchers("/api/v1/management/admin-write").hasAuthority(Permission.ADMIN_WRITE.getPermission())
                                        .requestMatchers("/api/v1/management/for-all").hasAnyAuthority(
                                                Permission.MEMBER_READ.getPermission(),
                                                Permission.MEMBER_WRITE.getPermission(),
                                                Permission.ADMIN_WRITE.getPermission(),
                                                Permission.ADMIN_READ.getPermission()
                                        )
                                        .anyRequest().permitAll()
//                                        .anyRequest().authenticated()
//                                        .requestMatchers("/api/v1/auth/authenticate").permitAll()
                )
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .authenticationProvider(authenticationProvider)
                .sessionManagement(sessionManagement -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        ;
        return http.build();
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/dto/response/AuthenticationResponse.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.dto.response;

public record AuthenticationResponse(
        String token
) {
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/dto/request/RegisterRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.dto.request;


import edu.miu.cs.cs489.resumerefinerai.auth.user.Role;

public record RegisterRequest(
        String firstName,
        String lastName,
        String username,
        String password,
        Role role
) {
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/dto/request/AuthenticationRequest.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.dto.request;

public record AuthenticationRequest(
        String username,
        String password
) {
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/repository/UserRepository.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.repository;

import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/user/User.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.user;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String firstName;
    private String lastName;

    @Column(unique = true, nullable = false)
    private String username;
    private String password;

    @Enumerated(EnumType.STRING)
    private Role role;

    public User(String firstName, String lastName, String username, String password, Role role) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.username = username;
        this.password = password;
        this.role = role;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return role.getAuthorities();
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/user/Permission.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.user;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum Permission {
    ADMIN_READ("admin:read"),
    ADMIN_WRITE("admin:write"),
    MEMBER_READ("member:read"),
    MEMBER_WRITE("member:write");

    @Getter
    private final String permission;
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/user/Role.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.user;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public enum Role {
    ADMIN(Set.of(Permission.ADMIN_WRITE, Permission.ADMIN_READ)),
    MEMBER(Set.of(Permission.MEMBER_WRITE, Permission.MEMBER_READ));

    @Getter
    private final Set<Permission> permissions;

    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<SimpleGrantedAuthority> authorities = getPermissions().stream()
                .map(permission -> new SimpleGrantedAuthority(permission.getPermission()))
                .collect(Collectors.toList());
        authorities.add(new SimpleGrantedAuthority("ROLE_"+name()));
        return authorities;
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/controller/AuthenticationController.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.controller;

import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.AuthenticationRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.RegisterRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.response.AuthenticationResponse;
import edu.miu.cs.cs489.resumerefinerai.auth.service.AuthenticationService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthenticationController {

    private final AuthenticationService authenticationService;
    /***
     * for /register
     */
    @PostMapping("/register")
    public ResponseEntity<AuthenticationResponse> register(@RequestBody RegisterRequest registerRequest) {
        AuthenticationResponse authenticationResponse = authenticationService.register(registerRequest);
        return ResponseEntity.status(HttpStatus.CREATED).body(authenticationResponse);
    }

    /***
     * for /authenticate
     */
    //AuthenticationResponse authenticate(authenticationRequest)
    @PostMapping("/authenticate")
    private ResponseEntity<AuthenticationResponse> authenticate(@RequestBody AuthenticationRequest authenticationRequest) {
        AuthenticationResponse authenticationResponse = authenticationService.authenticate(authenticationRequest);
        return ResponseEntity.status(HttpStatus.OK).body(authenticationResponse);
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/auth/service/AuthenticationService.java =====
package edu.miu.cs.cs489.resumerefinerai.auth.service;

import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.RegisterRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.request.AuthenticationRequest;
import edu.miu.cs.cs489.resumerefinerai.auth.dto.response.AuthenticationResponse;
import edu.miu.cs.cs489.resumerefinerai.config.JwtService;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import edu.miu.cs.cs489.resumerefinerai.exception.AuthenticationFailedException;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthenticationService {

    private final UserRepository userRepository;
    private final JwtService jwtService;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;

    public AuthenticationResponse authenticate(AuthenticationRequest request) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            request.username(),
                            request.password()
                    )
            );
            var user = (User) authentication.getPrincipal();
            String token = jwtService.generateToken(user);
            return new AuthenticationResponse(token);
        } catch (BadCredentialsException e) {
            throw new AuthenticationFailedException("Invalid username/password");
        }
    }


    public AuthenticationResponse register(RegisterRequest registerRequest) {

        if (userRepository.findByUsername(registerRequest.username()).isPresent()) {
            throw new RuntimeException("Username already exists");
        }

        User user = new User(
                registerRequest.firstName(),
                registerRequest.lastName(),
                registerRequest.username(),
                passwordEncoder.encode(registerRequest.password()),
                registerRequest.role()
        );
        User registeredUser = userRepository.save(user);
        //Generate token for this user
        String token = jwtService.generateToken(registeredUser);
        return new AuthenticationResponse(token);
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/ResumeRefinerAiApplication.java =====
package edu.miu.cs.cs489.resumerefinerai;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@PropertySource(value = "file:.env", ignoreResourceNotFound = true)
public class ResumeRefinerAiApplication {

    public static void main(String[] args) {
        SpringApplication.run(ResumeRefinerAiApplication.class, args);
    }

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/mapper/JobMapper.java =====
package edu.miu.cs.cs489.resumerefinerai.mapper;

import edu.miu.cs.cs489.resumerefinerai.dto.response.JobResponse;
import edu.miu.cs.cs489.resumerefinerai.model.Job;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface JobMapper {
    JobResponse toDto(Job job);
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/mapper/UserMapper.java =====
package edu.miu.cs.cs489.resumerefinerai.mapper;

import edu.miu.cs.cs489.resumerefinerai.dto.response.UserResponse;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.mapstruct.Mapper;

@Mapper(componentModel = "spring")
public interface UserMapper {
    UserResponse toDto(User user);
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/mapper/ProfileMapper.java =====
package edu.miu.cs.cs489.resumerefinerai.mapper;

import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.dto.response.ProfileResponse;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import org.mapstruct.*;

@Mapper(componentModel = "spring")
public interface ProfileMapper {
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "user", source = "user")
    Profile toEntity(CreateProfileRequest dto, User user);

    @Mapping(target = "username", source = "user.username")
    ProfileResponse toDto(Profile profile);
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/controller/ProfileController.java =====
package edu.miu.cs.cs489.resumerefinerai.controller;

import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.dto.response.ProfileResponse;
import edu.miu.cs.cs489.resumerefinerai.mapper.ProfileMapper;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.service.ProfileService;
import io.swagger.v3.oas.annotations.Parameter;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/v1/profiles")
@RequiredArgsConstructor
public class ProfileController {

    private final ProfileService profileService;
    private final ProfileMapper profileMapper;

    @PostMapping("/{username}")
    public ResponseEntity<ProfileResponse> createProfile(
            @PathVariable String username,
            @Valid @RequestBody CreateProfileRequest request
    ) {
        ProfileResponse profile = profileService.createProfile(username, request);
        return ResponseEntity.ok(profile);
    }

    @GetMapping("/{username}")
    public ResponseEntity<Page<ProfileResponse>> getUserProfiles(
            @PathVariable String username,
            @Parameter(description = "Page number (0-based)", example = "0")
            @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "Items per page", example = "10")
            @RequestParam(defaultValue = "10") int size,
            @Parameter(description = "Sorting criteria (e.g., 'profileName,asc')", example = "profileName,asc")
            @RequestParam(defaultValue = "profileName,asc") String[] sort) {

        // Parse sorting parameters (e.g., "fieldName,direction")
        Sort.Direction direction = sort[1].equalsIgnoreCase("desc") ? Sort.Direction.DESC : Sort.Direction.ASC;
        Sort sorting = Sort.by(direction, sort[0]);

        Pageable pageable = PageRequest.of(page, size, sorting);
        Page<Profile> profilesPage = profileService.getUserProfiles(username, pageable);

        // Map Profile entities to ProfileResponse DTOs
        Page<ProfileResponse> responsePage = profilesPage.map(profileMapper::toDto);
        return ResponseEntity.ok(responsePage);
    }

    @GetMapping("/{username}/{profileName}")
    public ResponseEntity<Profile> getSingleProfile(
            @PathVariable String username,
            @PathVariable String profileName) {
        return ResponseEntity.ok(profileService.getProfile(username, profileName));
    }


    @PostMapping("/{username}/{profileName}/upload")
    public ResponseEntity<String> uploadLatexZip(
            @PathVariable String username,
            @PathVariable String profileName,
            @RequestParam("file") MultipartFile file
    ) {
        // Validate file type
        if (file.isEmpty() || !"application/zip".equalsIgnoreCase(file.getContentType())) {
            return ResponseEntity.badRequest().body("Only ZIP files are allowed.");
        }
        // Validate file size (e.g., 5MB max)
        if (file.getSize() > 5 * 1024 * 1024) { // 5MB in bytes
            return ResponseEntity.badRequest().body("File too large (max 5MB).");
        }
        try {
            profileService.extractLatexZip(username, profileName, file);
            return ResponseEntity.ok("Upload and extraction successful.");
        } catch (RuntimeException | IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Upload failed: " + e.getMessage());
        }
    }



}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/controller/ResumeController.java =====
package edu.miu.cs.cs489.resumerefinerai.controller;

import edu.miu.cs.cs489.resumerefinerai.dto.request.UpdateResumeRequest;
import edu.miu.cs.cs489.resumerefinerai.service.ResumeService;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;

@RestController
@RequestMapping("/api/v1/resume")
public class ResumeController {

    private final ResumeService resumeService;

    public ResumeController(ResumeService resumeService) {
        this.resumeService = resumeService;
    }

    @PostMapping("/update")
    public ResponseEntity<String> updateResume(@RequestBody UpdateResumeRequest request) {
        try {
            resumeService.updateResume(request);
            return ResponseEntity.ok("Resume updated and compiled successfully.");
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
        }
    }

    @GetMapping("/download/{username}/{profileName}")
    public ResponseEntity<FileSystemResource> downloadResume(
            @PathVariable String username,
            @PathVariable String profileName
    ) {
        Path pdfPath = resumeService.getPdfPathForUser(username, profileName);
        File pdf = pdfPath.toFile();

        if (!pdf.exists()) return ResponseEntity.notFound().build();

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + profileName + ".pdf")
                .contentType(MediaType.APPLICATION_PDF)
                .body(new FileSystemResource(pdf));
    }

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/model/Profile.java =====
package edu.miu.cs.cs489.resumerefinerai.model;

import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(
        name = "profiles",
        uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "profile_name"})
)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Profile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "profile_name")
    private String profileName;

    private String profileDescription;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    public Profile(String dataEngineer, String s, User user) {
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/model/Job.java =====
package edu.miu.cs.cs489.resumerefinerai.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "jobs")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Job {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String jobDescription;

}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/service/ProfileService.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import edu.miu.cs.cs489.resumerefinerai.dto.request.CreateProfileRequest;
import edu.miu.cs.cs489.resumerefinerai.dto.response.ProfileResponse;
import edu.miu.cs.cs489.resumerefinerai.exception.DuplicateProfileException;
import edu.miu.cs.cs489.resumerefinerai.mapper.ProfileMapper;
import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.repository.ProfileRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.*;
import java.util.Comparator;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ProfileService {

    private final ProfileRepository profileRepository;
    private final UserRepository userRepository;
    private final ProfileMapper profileMapper;


    public ProfileResponse createProfile(String username, CreateProfileRequest request) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));

        boolean exists = profileRepository.existsByUserAndProfileName(user, request.getProfileName());
        if (exists) {
            throw new DuplicateProfileException("Profile name already exists for this user.");
        }


        Profile profile = profileMapper.toEntity(request, user);
        Profile savedProfile = profileRepository.save(profile);
        createLatexFolderStructure(user, savedProfile.getProfileName());
        return profileMapper.toDto(savedProfile);
    }


    public Page<Profile> getUserProfiles(String username, Pageable pageable) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        return profileRepository.findByUser(user, pageable);
    }

    public Profile getProfile(String username, String profileName) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return profileRepository.findByUserAndProfileName(user, profileName)
                .orElseThrow(() -> new RuntimeException("Profile not found"));
    }

    private void createLatexFolderStructure(User user, String profileName) {
        String userId = String.valueOf(user.getId());
        Path baseDir = Paths.get("src/main/resources/latex", userId, profileName);
        Path sectionsDir = baseDir.resolve("sections");

        try {
            // ðŸ’£ Delete old folder if it exists
            if (Files.exists(baseDir)) {
                deleteDirectoryRecursively(baseDir);
            }

            Files.createDirectories(sectionsDir);

            // Create empty .tex files
            List<String> sectionFiles = List.of(
                    "summary.tex", "skills.tex", "experience.tex",
                    "projects.tex", "educations.tex", "publications.tex"
            );
            for (String filename : sectionFiles) {
                Files.createFile(sectionsDir.resolve(filename));
            }

            Files.createFile(baseDir.resolve("header.tex"));
            Files.createFile(baseDir.resolve(profileName + ".tex"));

        } catch (IOException e) {
            throw new RuntimeException("Could not create LaTeX folder structure", e);
        }
    }

    private void deleteDirectoryRecursively(Path path) throws IOException {
        if (Files.notExists(path)) return;

        Files.walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(p -> {
                    try {
                        Files.deleteIfExists(p);
                    } catch (IOException e) {
                        throw new RuntimeException("Failed to delete " + p, e);
                    }
                });
    }

    public void extractLatexZip(String username, String profileName, MultipartFile zipFile) throws IOException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Profile profile = profileRepository.findByUserAndProfileName(user, profileName)
                .orElseThrow(() -> new RuntimeException("Profile not found"));

        Path extractTo = Paths.get("src/main/resources/template", String.valueOf(user.getId()), profileName);
        Files.createDirectories(extractTo);

        Path tempZip = Files.createTempFile("upload-", ".zip");
        zipFile.transferTo(tempZip.toFile());

        System.out.println("TEMP ZIP PATH: " + tempZip);
        System.out.println("Exists? " + Files.exists(tempZip));
        System.out.println("Size: " + Files.size(tempZip));

        try (FileSystem zipFs = FileSystems.newFileSystem(tempZip, (ClassLoader) null)) {
            for (Path root : zipFs.getRootDirectories()) {
                Files.walk(root)
                        .filter(Files::isRegularFile)
                        .forEach(zipEntry -> {
                            try {
                                Path relativePath = root.relativize(zipEntry);
                                Path target = extractTo.resolve(relativePath.toString());
                                Files.createDirectories(target.getParent());
                                Files.copy(zipEntry, target, StandardCopyOption.REPLACE_EXISTING);
                            } catch (IOException e) {
                                throw new RuntimeException("Failed to extract: " + zipEntry, e);
                            }
                        });
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to open zip file: " + tempZip, e);
        } finally {
            Files.deleteIfExists(tempZip);
        }
    }

}===== ./main/java/edu/miu/cs/cs489/resumerefinerai/service/OpenAIService.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import com.openai.client.OpenAIClient;
import com.openai.client.okhttp.OpenAIOkHttpClient;
import com.openai.models.ChatModel;
import com.openai.models.chat.completions.ChatCompletion;
import com.openai.models.chat.completions.ChatCompletionCreateParams;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class OpenAIService {

    private final OpenAIClient client;

    public OpenAIService(@Value("${openai.api.key}") String apiKey) {
        this.client = OpenAIOkHttpClient.builder()
                .apiKey(apiKey)
                .build();
    }

    public String getUpdatedSection(String sectionName, String sectionContent, String jobDescription) {
        String prompt = "You are a resume writing expert. Rewrite ONLY the LaTeX content of the resume section '" + sectionName +
                "' based on the job description below. Return ONLY LaTeX code between \\begin{} and \\end{}, no explanation, no Markdown, no notes.\n\n" +
                "Job Description:\n" + jobDescription + "\n\nCurrent LaTeX Section:\n" + sectionContent;


        ChatCompletionCreateParams params = ChatCompletionCreateParams.builder()
                .addUserMessage(prompt)
                .model(ChatModel.GPT_4_1)
                .build();

        ChatCompletion completion = client.chat().completions().create(params);
        return completion.choices().get(0).message().content().orElse("%% Error: no content received");
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/service/ResumeService.java =====
package edu.miu.cs.cs489.resumerefinerai.service;

import edu.miu.cs.cs489.resumerefinerai.model.Profile;
import edu.miu.cs.cs489.resumerefinerai.dto.request.UpdateResumeRequest;
import edu.miu.cs.cs489.resumerefinerai.repository.ProfileRepository;
import edu.miu.cs.cs489.resumerefinerai.auth.user.User;
import edu.miu.cs.cs489.resumerefinerai.auth.repository.UserRepository;
import edu.miu.cs.cs489.resumerefinerai.util.DockerLatexCompiler;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.*;
import java.util.Comparator;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ResumeService {

    private final OpenAIService openAIService;
    private final ProfileRepository profileRepository;
    private final UserRepository userRepository;

    public void updateResume(UpdateResumeRequest request) throws IOException {
        // 1. Get user and profile
        User user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found"));
        Profile profile = profileRepository.findByUserAndProfileName(user, request.getProfileName())
                .orElseThrow(() -> new RuntimeException("Profile not found"));

        String userId = String.valueOf(user.getId());
        String profileName = profile.getProfileName();
        String resumeFileName = user.getFirstName() + " " + user.getLastName() + " Resume.tex";

        // 2. Build paths
        Path templateRoot = Paths.get("src/main/resources/template", userId, profileName);
        Path latexRoot = Paths.get("src/main/resources/latex", userId, profileName);
        Path mainTexFile = latexRoot.resolve(resumeFileName);

        // 3. Clean and copy template to latex
        if (Files.exists(latexRoot)) {
            deleteDirectoryRecursively(latexRoot);
        }
        Files.createDirectories(latexRoot);
        copyDirectoryRecursively(templateRoot, latexRoot);

        // 4. Update selective sections using OpenAI
        List<String> updatableSections = List.of("summary.tex", "skills.tex");  //, "experience.tex"
        Path sectionsDir = latexRoot.resolve("sections");

        for (String section : updatableSections) {
            Path targetFile = sectionsDir.resolve(section);
            if (!Files.exists(targetFile)) {
                throw new RuntimeException("Missing section file: " + targetFile.toAbsolutePath());
            }

            String original = Files.readString(targetFile);
            String updated = openAIService.getUpdatedSection(section, original, request.getJobDescription());
            Files.writeString(targetFile, updated);

            System.out.println("Section updated: " + section);
        }

        // 5. Compile with Docker
        boolean compiled = DockerLatexCompiler.compileWithDocker(mainTexFile);
        if (!compiled) {
            throw new RuntimeException("LaTeX compilation failed.");
        }

        System.out.println("Resume compiled: " + mainTexFile);
    }

    private void deleteDirectoryRecursively(Path path) throws IOException {
        Files.walk(path)
                .sorted(Comparator.reverseOrder())
                .forEach(p -> {
                    try {
                        Files.deleteIfExists(p);
                    } catch (IOException e) {
                        throw new RuntimeException("Failed to delete " + p, e);
                    }
                });
    }

    private void copyDirectoryRecursively(Path source, Path target) throws IOException {
        Files.walk(source).forEach(src -> {
            try {
                Path dest = target.resolve(source.relativize(src));
                if (Files.isDirectory(src)) {
                    Files.createDirectories(dest);
                } else {
                    Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);
                }
            } catch (IOException e) {
                throw new RuntimeException("Failed to copy " + src + " to " + target, e);
            }
        });
    }


    public Path getCompiledPdfPath(String userId, String profileName) {
        return Paths.get("src/main/resources/latex", userId, profileName, profileName + ".pdf");
    }

    public Path getPdfPathForUser(String username, String profileName) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));
        String fileName = user.getFirstName() + " " + user.getLastName() + " Resume.pdf";
        return Paths.get("src/main/resources/latex", String.valueOf(user.getId()), profileName, fileName);
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/exception/GlobalExceptionHandler.java =====
package edu.miu.cs.cs489.resumerefinerai.exception;

import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    // Handle validation errors (e.g., @NotBlank, @Size)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(
            MethodArgumentNotValidException ex, HttpServletRequest request) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String message = error.getDefaultMessage();
            errors.put(fieldName, message);
        });
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }

    // Handle DuplicateProfileException (custom)
    @ExceptionHandler(DuplicateProfileException.class)
    public ResponseEntity<Map<String, String>> handleDuplicateProfileException(
            DuplicateProfileException ex, HttpServletRequest request) {
        return buildErrorResponse(ex, HttpStatus.CONFLICT, request);
    }

    // Handle authentication failures (invalid username/password)
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<Map<String, String>> handleBadCredentialsException(
            BadCredentialsException ex, HttpServletRequest request) {
        return buildErrorResponse(ex, HttpStatus.UNAUTHORIZED, request);
    }

    // Handle generic exceptions (fallback)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleGenericException(
            Exception ex, HttpServletRequest request) {
        return buildErrorResponse(ex, HttpStatus.INTERNAL_SERVER_ERROR, request);
    }

    // Helper to build consistent error responses
    private ResponseEntity<Map<String, String>> buildErrorResponse(
            Exception ex, HttpStatus status, HttpServletRequest request) {
        Map<String, String> errorDetails = new HashMap<>();
        errorDetails.put("timestamp", LocalDateTime.now().toString());
        errorDetails.put("status", String.valueOf(status.value()));
        errorDetails.put("error", status.getReasonPhrase());
        errorDetails.put("message", ex.getMessage());
        errorDetails.put("path", request.getRequestURI());
        return ResponseEntity.status(status).body(errorDetails);
    }


    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String, String>> handleIllegalArgumentException(
            IllegalArgumentException ex, HttpServletRequest request) {
        return buildErrorResponse(ex, HttpStatus.BAD_REQUEST, request);
    }


}===== ./main/java/edu/miu/cs/cs489/resumerefinerai/exception/DuplicateProfileException.java =====
package edu.miu.cs.cs489.resumerefinerai.exception;

public class DuplicateProfileException extends RuntimeException {
    public DuplicateProfileException(String message) {
        super(message);
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/exception/AuthenticationFailedException.java =====
package edu.miu.cs.cs489.resumerefinerai.exception;

public class AuthenticationFailedException extends RuntimeException {
    public AuthenticationFailedException(String message) {
        super(message);
    }
}

===== ./main/java/edu/miu/cs/cs489/resumerefinerai/secured/AdminController.java =====
package edu.miu.cs.cs489.resumerefinerai.secured;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/admin")
public class AdminController {

    @GetMapping
    public String getAdmin() {
        return "Admin: secured end point";
    }
}
===== ./main/java/edu/miu/cs/cs489/resumerefinerai/secured/MemberController.java =====
package edu.miu.cs.cs489.resumerefinerai.secured;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/management")
public class MemberController {

    @GetMapping
    public String getMember() {
        return "Member: secured end point";
    }

    @GetMapping("/admin-write")
    @PreAuthorize("hasAuthority('admin:write')")
    public String memberOnlyForAdminWrite() {
        return "Member: secured end point only for admin write";
    }

    @GetMapping("for-all")
    @PreAuthorize("hasAnyAuthority('admin-write', 'admin-read', 'member-write', 'member-read')")
    public String memberOnlyForAll() {
        return "Member: secured end point only for all";
    }

}
